{"version":3,"sources":["../node_modules/optimism/lib/bundle.esm.js"],"names":["defaultDispose","Cache","max","dispose","Infinity","this","map","Map","newest","oldest","prototype","has","key","get","entry","getEntry","value","older","newer","set","clean","size","delete","parentEntrySlot","reusableEmptyArray","emptySetPool","POOL_TARGET_SIZE","assert","condition","optionalMessage","Error","valueGet","length","Entry","fn","args","parents","Set","childValues","dirtyChildren","dirty","recomputing","count","recompute","child","parent","getValue","add","mightBeDirty","reportDirtyChild","reportCleanChild","rememberParent","maybeReportOrphan","originalChildren","forgetChildren","withValue","recomputeNewValue","subscribe","maybeUnsubscribe","unsubscribe","apply","e","setDirty","maybeSubscribe","reportClean","setClean","forEach","reallyRecompute","reportDirty","_this","forgetChild","pop","childValue","slice","a","b","len","valueIs","removeDirtyChild","dc","push","reportOrphan","children","_value","KeyTrie","weakness","lookup","array","_i","arguments","lookupArray","node","getChildTrie","data","Object","create","isObjRef","weak","WeakMap","strong","keyTrie","defaultMakeCacheKey","caches","wrap","originalFunction","options","cache","Math","pow","disposable","makeCacheKey","optimistic","hasValue","Array","call","clear"],"mappings":"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","file":"static/js/nm.optimism.3c846905.chunk.js","sourcesContent":["import { Slot } from '@wry/context';\nexport { asyncFromGen, bind as bindContext, noContext, setTimeout } from '@wry/context';\n\nfunction defaultDispose() {}\n\nvar Cache =\n/** @class */\nfunction () {\n  function Cache(max, dispose) {\n    if (max === void 0) {\n      max = Infinity;\n    }\n\n    if (dispose === void 0) {\n      dispose = defaultDispose;\n    }\n\n    this.max = max;\n    this.dispose = dispose;\n    this.map = new Map();\n    this.newest = null;\n    this.oldest = null;\n  }\n\n  Cache.prototype.has = function (key) {\n    return this.map.has(key);\n  };\n\n  Cache.prototype.get = function (key) {\n    var entry = this.getEntry(key);\n    return entry && entry.value;\n  };\n\n  Cache.prototype.getEntry = function (key) {\n    var entry = this.map.get(key);\n\n    if (entry && entry !== this.newest) {\n      var older = entry.older,\n          newer = entry.newer;\n\n      if (newer) {\n        newer.older = older;\n      }\n\n      if (older) {\n        older.newer = newer;\n      }\n\n      entry.older = this.newest;\n      entry.older.newer = entry;\n      entry.newer = null;\n      this.newest = entry;\n\n      if (entry === this.oldest) {\n        this.oldest = newer;\n      }\n    }\n\n    return entry;\n  };\n\n  Cache.prototype.set = function (key, value) {\n    var entry = this.getEntry(key);\n\n    if (entry) {\n      return entry.value = value;\n    }\n\n    entry = {\n      key: key,\n      value: value,\n      newer: null,\n      older: this.newest\n    };\n\n    if (this.newest) {\n      this.newest.newer = entry;\n    }\n\n    this.newest = entry;\n    this.oldest = this.oldest || entry;\n    this.map.set(key, entry);\n    return entry.value;\n  };\n\n  Cache.prototype.clean = function () {\n    while (this.oldest && this.map.size > this.max) {\n      this.delete(this.oldest.key);\n    }\n  };\n\n  Cache.prototype.delete = function (key) {\n    var entry = this.map.get(key);\n\n    if (entry) {\n      if (entry === this.newest) {\n        this.newest = entry.older;\n      }\n\n      if (entry === this.oldest) {\n        this.oldest = entry.newer;\n      }\n\n      if (entry.newer) {\n        entry.newer.older = entry.older;\n      }\n\n      if (entry.older) {\n        entry.older.newer = entry.newer;\n      }\n\n      this.map.delete(key);\n      this.dispose(entry.value, key);\n      return true;\n    }\n\n    return false;\n  };\n\n  return Cache;\n}();\n\nvar parentEntrySlot = new Slot();\nvar reusableEmptyArray = [];\nvar emptySetPool = [];\nvar POOL_TARGET_SIZE = 100; // Since this package might be used browsers, we should avoid using the\n// Node built-in assert module.\n\nfunction assert(condition, optionalMessage) {\n  if (!condition) {\n    throw new Error(optionalMessage || \"assertion failure\");\n  }\n}\n\nfunction valueIs(a, b) {\n  var len = a.length;\n  return (// Unknown values are not equal to each other.\n    len > 0 && // Both values must be ordinary (or both exceptional) to be equal.\n    len === b.length && // The underlying value or exception must be the same.\n    a[len - 1] === b[len - 1]\n  );\n}\n\nfunction valueGet(value) {\n  switch (value.length) {\n    case 0:\n      throw new Error(\"unknown value\");\n\n    case 1:\n      return value[0];\n\n    case 2:\n      throw value[1];\n  }\n}\n\nfunction valueCopy(value) {\n  return value.slice(0);\n}\n\nvar Entry =\n/** @class */\nfunction () {\n  function Entry(fn, args) {\n    this.fn = fn;\n    this.args = args;\n    this.parents = new Set();\n    this.childValues = new Map(); // When this Entry has children that are dirty, this property becomes\n    // a Set containing other Entry objects, borrowed from emptySetPool.\n    // When the set becomes empty, it gets recycled back to emptySetPool.\n\n    this.dirtyChildren = null;\n    this.dirty = true;\n    this.recomputing = false;\n    this.value = [];\n    ++Entry.count;\n  } // This is the most important method of the Entry API, because it\n  // determines whether the cached this.value can be returned immediately,\n  // or must be recomputed. The overall performance of the caching system\n  // depends on the truth of the following observations: (1) this.dirty is\n  // usually false, (2) this.dirtyChildren is usually null/empty, and thus\n  // (3) valueGet(this.value) is usually returned without recomputation.\n\n\n  Entry.prototype.recompute = function () {\n    assert(!this.recomputing, \"already recomputing\");\n\n    if (!rememberParent(this) && maybeReportOrphan(this)) {\n      // The recipient of the entry.reportOrphan callback decided to dispose\n      // of this orphan entry by calling entry.dispose(), so we don't need to\n      // (and should not) proceed with the recomputation.\n      return void 0;\n    }\n\n    return mightBeDirty(this) ? reallyRecompute(this) : valueGet(this.value);\n  };\n\n  Entry.prototype.setDirty = function () {\n    if (this.dirty) return;\n    this.dirty = true;\n    this.value.length = 0;\n    reportDirty(this); // We can go ahead and unsubscribe here, since any further dirty\n    // notifications we receive will be redundant, and unsubscribing may\n    // free up some resources, e.g. file watchers.\n\n    maybeUnsubscribe(this);\n  };\n\n  Entry.prototype.dispose = function () {\n    var _this = this;\n\n    forgetChildren(this).forEach(maybeReportOrphan);\n    maybeUnsubscribe(this); // Because this entry has been kicked out of the cache (in index.js),\n    // we've lost the ability to find out if/when this entry becomes dirty,\n    // whether that happens through a subscription, because of a direct call\n    // to entry.setDirty(), or because one of its children becomes dirty.\n    // Because of this loss of future information, we have to assume the\n    // worst (that this entry might have become dirty very soon), so we must\n    // immediately mark this entry's parents as dirty. Normally we could\n    // just call entry.setDirty() rather than calling parent.setDirty() for\n    // each parent, but that would leave this entry in parent.childValues\n    // and parent.dirtyChildren, which would prevent the child from being\n    // truly forgotten.\n\n    this.parents.forEach(function (parent) {\n      parent.setDirty();\n      forgetChild(parent, _this);\n    });\n  };\n\n  Entry.count = 0;\n  return Entry;\n}();\n\nfunction rememberParent(child) {\n  var parent = parentEntrySlot.getValue();\n\n  if (parent) {\n    child.parents.add(parent);\n\n    if (!parent.childValues.has(child)) {\n      parent.childValues.set(child, []);\n    }\n\n    if (mightBeDirty(child)) {\n      reportDirtyChild(parent, child);\n    } else {\n      reportCleanChild(parent, child);\n    }\n\n    return parent;\n  }\n}\n\nfunction reallyRecompute(entry) {\n  // Since this recomputation is likely to re-remember some of this\n  // entry's children, we forget our children here but do not call\n  // maybeReportOrphan until after the recomputation finishes.\n  var originalChildren = forgetChildren(entry); // Set entry as the parent entry while calling recomputeNewValue(entry).\n\n  parentEntrySlot.withValue(entry, recomputeNewValue, [entry]);\n\n  if (maybeSubscribe(entry)) {\n    // If we successfully recomputed entry.value and did not fail to\n    // (re)subscribe, then this Entry is no longer explicitly dirty.\n    setClean(entry);\n  } // Now that we've had a chance to re-remember any children that were\n  // involved in the recomputation, we can safely report any orphan\n  // children that remain.\n\n\n  originalChildren.forEach(maybeReportOrphan);\n  return valueGet(entry.value);\n}\n\nfunction recomputeNewValue(entry) {\n  entry.recomputing = true; // Set entry.value as unknown.\n\n  entry.value.length = 0;\n\n  try {\n    // If entry.fn succeeds, entry.value will become a normal Value.\n    entry.value[0] = entry.fn.apply(null, entry.args);\n  } catch (e) {\n    // If entry.fn throws, entry.value will become exceptional.\n    entry.value[1] = e;\n  } // Either way, this line is always reached.\n\n\n  entry.recomputing = false;\n}\n\nfunction mightBeDirty(entry) {\n  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\n}\n\nfunction setClean(entry) {\n  entry.dirty = false;\n\n  if (mightBeDirty(entry)) {\n    // This Entry may still have dirty children, in which case we can't\n    // let our parents know we're clean just yet.\n    return;\n  }\n\n  reportClean(entry);\n}\n\nfunction reportDirty(child) {\n  child.parents.forEach(function (parent) {\n    return reportDirtyChild(parent, child);\n  });\n}\n\nfunction reportClean(child) {\n  child.parents.forEach(function (parent) {\n    return reportCleanChild(parent, child);\n  });\n} // Let a parent Entry know that one of its children may be dirty.\n\n\nfunction reportDirtyChild(parent, child) {\n  // Must have called rememberParent(child) before calling\n  // reportDirtyChild(parent, child).\n  assert(parent.childValues.has(child));\n  assert(mightBeDirty(child));\n\n  if (!parent.dirtyChildren) {\n    parent.dirtyChildren = emptySetPool.pop() || new Set();\n  } else if (parent.dirtyChildren.has(child)) {\n    // If we already know this child is dirty, then we must have already\n    // informed our own parents that we are dirty, so we can terminate\n    // the recursion early.\n    return;\n  }\n\n  parent.dirtyChildren.add(child);\n  reportDirty(parent);\n} // Let a parent Entry know that one of its children is no longer dirty.\n\n\nfunction reportCleanChild(parent, child) {\n  // Must have called rememberChild(child) before calling\n  // reportCleanChild(parent, child).\n  assert(parent.childValues.has(child));\n  assert(!mightBeDirty(child));\n  var childValue = parent.childValues.get(child);\n\n  if (childValue.length === 0) {\n    parent.childValues.set(child, valueCopy(child.value));\n  } else if (!valueIs(childValue, child.value)) {\n    parent.setDirty();\n  }\n\n  removeDirtyChild(parent, child);\n\n  if (mightBeDirty(parent)) {\n    return;\n  }\n\n  reportClean(parent);\n}\n\nfunction removeDirtyChild(parent, child) {\n  var dc = parent.dirtyChildren;\n\n  if (dc) {\n    dc.delete(child);\n\n    if (dc.size === 0) {\n      if (emptySetPool.length < POOL_TARGET_SIZE) {\n        emptySetPool.push(dc);\n      }\n\n      parent.dirtyChildren = null;\n    }\n  }\n} // If the given entry has a reportOrphan method, and no remaining parents,\n// call entry.reportOrphan and return true iff it returns true. The\n// reportOrphan function should return true to indicate entry.dispose()\n// has been called, and the entry has been removed from any other caches\n// (see index.js for the only current example).\n\n\nfunction maybeReportOrphan(entry) {\n  return entry.parents.size === 0 && typeof entry.reportOrphan === \"function\" && entry.reportOrphan() === true;\n} // Removes all children from this entry and returns an array of the\n// removed children.\n\n\nfunction forgetChildren(parent) {\n  var children = reusableEmptyArray;\n\n  if (parent.childValues.size > 0) {\n    children = [];\n    parent.childValues.forEach(function (_value, child) {\n      forgetChild(parent, child);\n      children.push(child);\n    });\n  } // After we forget all our children, this.dirtyChildren must be empty\n  // and therefore must have been reset to null.\n\n\n  assert(parent.dirtyChildren === null);\n  return children;\n}\n\nfunction forgetChild(parent, child) {\n  child.parents.delete(parent);\n  parent.childValues.delete(child);\n  removeDirtyChild(parent, child);\n}\n\nfunction maybeSubscribe(entry) {\n  if (typeof entry.subscribe === \"function\") {\n    try {\n      maybeUnsubscribe(entry); // Prevent double subscriptions.\n\n      entry.unsubscribe = entry.subscribe.apply(null, entry.args);\n    } catch (e) {\n      // If this Entry has a subscribe function and it threw an exception\n      // (or an unsubscribe function it previously returned now throws),\n      // return false to indicate that we were not able to subscribe (or\n      // unsubscribe), and this Entry should remain dirty.\n      entry.setDirty();\n      return false;\n    }\n  } // Returning true indicates either that there was no entry.subscribe\n  // function or that it succeeded.\n\n\n  return true;\n}\n\nfunction maybeUnsubscribe(entry) {\n  var unsubscribe = entry.unsubscribe;\n\n  if (typeof unsubscribe === \"function\") {\n    entry.unsubscribe = void 0;\n    unsubscribe();\n  }\n} // A trie data structure that holds object keys weakly, yet can also hold\n// non-object keys, unlike the native `WeakMap`.\n\n\nvar KeyTrie =\n/** @class */\nfunction () {\n  function KeyTrie(weakness) {\n    this.weakness = weakness;\n  }\n\n  KeyTrie.prototype.lookup = function () {\n    var array = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      array[_i] = arguments[_i];\n    }\n\n    return this.lookupArray(array);\n  };\n\n  KeyTrie.prototype.lookupArray = function (array) {\n    var node = this;\n    array.forEach(function (key) {\n      return node = node.getChildTrie(key);\n    });\n    return node.data || (node.data = Object.create(null));\n  };\n\n  KeyTrie.prototype.getChildTrie = function (key) {\n    var map = this.weakness && isObjRef(key) ? this.weak || (this.weak = new WeakMap()) : this.strong || (this.strong = new Map());\n    var child = map.get(key);\n    if (!child) map.set(key, child = new KeyTrie(this.weakness));\n    return child;\n  };\n\n  return KeyTrie;\n}();\n\nfunction isObjRef(value) {\n  switch (typeof value) {\n    case \"object\":\n      if (value === null) break;\n    // Fall through to return true...\n\n    case \"function\":\n      return true;\n  }\n\n  return false;\n} // The defaultMakeCacheKey function is remarkably powerful, because it gives\n// a unique object for any shallow-identical list of arguments. If you need\n// to implement a custom makeCacheKey function, you may find it helpful to\n// delegate the final work to defaultMakeCacheKey, which is why we export it\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\n// does not support WeakMap, or you have the ability to return a string key.\n// In those cases, just write your own custom makeCacheKey functions.\n\n\nvar keyTrie = new KeyTrie(typeof WeakMap === \"function\");\n\nfunction defaultMakeCacheKey() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  return keyTrie.lookupArray(args);\n}\n\nvar caches = new Set();\n\nfunction wrap(originalFunction, options) {\n  if (options === void 0) {\n    options = Object.create(null);\n  }\n\n  var cache = new Cache(options.max || Math.pow(2, 16), function (entry) {\n    return entry.dispose();\n  });\n  var disposable = !!options.disposable;\n  var makeCacheKey = options.makeCacheKey || defaultMakeCacheKey;\n\n  function optimistic() {\n    if (disposable && !parentEntrySlot.hasValue()) {\n      // If there's no current parent computation, and this wrapped\n      // function is disposable (meaning we don't care about entry.value,\n      // just dependency tracking), then we can short-cut everything else\n      // in this function, because entry.recompute() is going to recycle\n      // the entry object without recomputing anything, anyway.\n      return void 0;\n    }\n\n    var key = makeCacheKey.apply(null, arguments);\n\n    if (key === void 0) {\n      return originalFunction.apply(null, arguments);\n    }\n\n    var args = Array.prototype.slice.call(arguments);\n    var entry = cache.get(key);\n\n    if (entry) {\n      entry.args = args;\n    } else {\n      entry = new Entry(originalFunction, args);\n      cache.set(key, entry);\n      entry.subscribe = options.subscribe;\n\n      if (disposable) {\n        entry.reportOrphan = function () {\n          return cache.delete(key);\n        };\n      }\n    }\n\n    var value = entry.recompute(); // Move this entry to the front of the least-recently used queue,\n    // since we just finished computing its value.\n\n    cache.set(key, entry);\n    caches.add(cache); // Clean up any excess entries in the cache, but only if there is no\n    // active parent entry, meaning we're not in the middle of a larger\n    // computation that might be flummoxed by the cleaning.\n\n    if (!parentEntrySlot.hasValue()) {\n      caches.forEach(function (cache) {\n        return cache.clean();\n      });\n      caches.clear();\n    } // If options.disposable is truthy, the caller of wrap is telling us\n    // they don't care about the result of entry.recompute(), so we should\n    // avoid returning the value, so it won't be accidentally used.\n\n\n    return disposable ? void 0 : value;\n  }\n\n  optimistic.dirty = function () {\n    var key = makeCacheKey.apply(null, arguments);\n    var child = key !== void 0 && cache.get(key);\n\n    if (child) {\n      child.setDirty();\n    }\n  };\n\n  return optimistic;\n}\n\nexport { KeyTrie, defaultMakeCacheKey, wrap };"],"sourceRoot":""}