{"version":3,"sources":["../node_modules/@wry/equality/lib/equality.esm.js","../node_modules/@wry/context/lib/context.esm.js"],"names":["_a","Object","prototype","toString","hasOwnProperty","previousComparisons","Map","equal","a","b","check","aTag","call","bTag","length","previouslyCompared","aKeys","keys","bKeys","keyCount","k","key","name","message","size","aIterator","entries","isMap","info","next","done","value","aKey","aValue","has","get","clear","bSet","set","Set","add","currentContext","MISSING_VALUE","idCounter","host","Array","Slot","this","id","Date","now","Math","random","slice","join","hasValue","context_1","parent","slots","getValue","withValue","callback","args","thisArg","__proto__","apply","bind","context","saved","arguments","noContext","defineProperty","enumerable","writable","configurable"],"mappings":"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","file":"static/js/nm.wry.f83bb1bf.chunk.js","sourcesContent":["var _a = Object.prototype,\n    toString = _a.toString,\n    hasOwnProperty = _a.hasOwnProperty;\nvar previousComparisons = new Map();\n/**\r\n * Performs a deep equality check on two JavaScript values, tolerating cycles.\r\n */\n\nfunction equal(a, b) {\n  try {\n    return check(a, b);\n  } finally {\n    previousComparisons.clear();\n  }\n}\n\nfunction check(a, b) {\n  // If the two values are strictly equal, our job is easy.\n  if (a === b) {\n    return true;\n  } // Object.prototype.toString returns a representation of the runtime type of\n  // the given value that is considerably more precise than typeof.\n\n\n  var aTag = toString.call(a);\n  var bTag = toString.call(b); // If the runtime types of a and b are different, they could maybe be equal\n  // under some interpretation of equality, but for simplicity and performance\n  // we just return false instead.\n\n  if (aTag !== bTag) {\n    return false;\n  }\n\n  switch (aTag) {\n    case '[object Array]':\n      // Arrays are a lot like other objects, but we can cheaply compare their\n      // lengths as a short-cut before comparing their elements.\n      if (a.length !== b.length) return false;\n    // Fall through to object case...\n\n    case '[object Object]':\n      {\n        if (previouslyCompared(a, b)) return true;\n        var aKeys = Object.keys(a);\n        var bKeys = Object.keys(b); // If `a` and `b` have a different number of enumerable keys, they\n        // must be different.\n\n        var keyCount = aKeys.length;\n        if (keyCount !== bKeys.length) return false; // Now make sure they have the same keys.\n\n        for (var k = 0; k < keyCount; ++k) {\n          if (!hasOwnProperty.call(b, aKeys[k])) {\n            return false;\n          }\n        } // Finally, check deep equality of all child properties.\n\n\n        for (var k = 0; k < keyCount; ++k) {\n          var key = aKeys[k];\n\n          if (!check(a[key], b[key])) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n    case '[object Error]':\n      return a.name === b.name && a.message === b.message;\n\n    case '[object Number]':\n      // Handle NaN, which is !== itself.\n      if (a !== a) return b !== b;\n    // Fall through to shared +a === +b case...\n\n    case '[object Boolean]':\n    case '[object Date]':\n      return +a === +b;\n\n    case '[object RegExp]':\n    case '[object String]':\n      return a == \"\" + b;\n\n    case '[object Map]':\n    case '[object Set]':\n      {\n        if (a.size !== b.size) return false;\n        if (previouslyCompared(a, b)) return true;\n        var aIterator = a.entries();\n        var isMap = aTag === '[object Map]';\n\n        while (true) {\n          var info = aIterator.next();\n          if (info.done) break; // If a instanceof Set, aValue === aKey.\n\n          var _a = info.value,\n              aKey = _a[0],\n              aValue = _a[1]; // So this works the same way for both Set and Map.\n\n          if (!b.has(aKey)) {\n            return false;\n          } // However, we care about deep equality of values only when dealing\n          // with Map structures.\n\n\n          if (isMap && !check(aValue, b.get(aKey))) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n  } // Otherwise the values are not equal.\n\n\n  return false;\n}\n\nfunction previouslyCompared(a, b) {\n  // Though cyclic references can make an object graph appear infinite from the\n  // perspective of a depth-first traversal, the graph still contains a finite\n  // number of distinct object references. We use the previousComparisons cache\n  // to avoid comparing the same pair of object references more than once, which\n  // guarantees termination (even if we end up comparing every object in one\n  // graph to every object in the other graph, which is extremely unlikely),\n  // while still allowing weird isomorphic structures (like rings with different\n  // lengths) a chance to pass the equality test.\n  var bSet = previousComparisons.get(a);\n\n  if (bSet) {\n    // Return true here because we can be sure false will be returned somewhere\n    // else if the objects are not equivalent.\n    if (bSet.has(b)) return true;\n  } else {\n    previousComparisons.set(a, bSet = new Set());\n  }\n\n  bSet.add(b);\n  return false;\n}\n\nexport default equal;\nexport { equal };","// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nvar currentContext = null; // This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\n\nvar MISSING_VALUE = {};\nvar idCounter = 1; // Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\n\nvar makeSlotClass = function makeSlotClass() {\n  return (\n    /** @class */\n    function () {\n      function Slot() {\n        // If you have a Slot object, you can find out its slot.id, but you cannot\n        // guess the slot.id of a Slot you don't have access to, thanks to the\n        // randomized suffix.\n        this.id = [\"slot\", idCounter++, Date.now(), Math.random().toString(36).slice(2)].join(\":\");\n      }\n\n      Slot.prototype.hasValue = function () {\n        for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {\n          // We use the Slot object iself as a key to its value, which means the\n          // value cannot be obtained without a reference to the Slot object.\n          if (this.id in context_1.slots) {\n            var value = context_1.slots[this.id];\n            if (value === MISSING_VALUE) break;\n\n            if (context_1 !== currentContext) {\n              // Cache the value in currentContext.slots so the next lookup will\n              // be faster. This caching is safe because the tree of contexts and\n              // the values of the slots are logically immutable.\n              currentContext.slots[this.id] = value;\n            }\n\n            return true;\n          }\n        }\n\n        if (currentContext) {\n          // If a value was not found for this Slot, it's never going to be found\n          // no matter how many times we look it up, so we might as well cache\n          // the absence of the value, too.\n          currentContext.slots[this.id] = MISSING_VALUE;\n        }\n\n        return false;\n      };\n\n      Slot.prototype.getValue = function () {\n        if (this.hasValue()) {\n          return currentContext.slots[this.id];\n        }\n      };\n\n      Slot.prototype.withValue = function (value, callback, // Given the prevalence of arrow functions, specifying arguments is likely\n      // to be much more common than specifying `this`, hence this ordering:\n      args, thisArg) {\n        var _a;\n\n        var slots = (_a = {\n          __proto__: null\n        }, _a[this.id] = value, _a);\n        var parent = currentContext;\n        currentContext = {\n          parent: parent,\n          slots: slots\n        };\n\n        try {\n          // Function.prototype.apply allows the arguments array argument to be\n          // omitted or undefined, so args! is fine here.\n          return callback.apply(thisArg, args);\n        } finally {\n          currentContext = parent;\n        }\n      }; // Capture the current context and wrap a callback function so that it\n      // reestablishes the captured context when called.\n\n\n      Slot.bind = function (callback) {\n        var context = currentContext;\n        return function () {\n          var saved = currentContext;\n\n          try {\n            currentContext = context;\n            return callback.apply(this, arguments);\n          } finally {\n            currentContext = saved;\n          }\n        };\n      }; // Immediately run a callback function without any captured context.\n\n\n      Slot.noContext = function (callback, // Given the prevalence of arrow functions, specifying arguments is likely\n      // to be much more common than specifying `this`, hence this ordering:\n      args, thisArg) {\n        if (currentContext) {\n          var saved = currentContext;\n\n          try {\n            currentContext = null; // Function.prototype.apply allows the arguments array argument to be\n            // omitted or undefined, so args! is fine here.\n\n            return callback.apply(thisArg, args);\n          } finally {\n            currentContext = saved;\n          }\n        } else {\n          return callback.apply(thisArg, args);\n        }\n      };\n\n      return Slot;\n    }()\n  );\n}; // We store a single global implementation of the Slot class as a permanent\n// non-enumerable symbol property of the Array constructor. This obfuscation\n// does nothing to prevent access to the Slot class, but at least it ensures\n// the implementation (i.e. currentContext) cannot be tampered with, and all\n// copies of the @wry/context package (hopefully just one) will share the\n// same Slot implementation. Since the first copy of the @wry/context package\n// to be imported wins, this technique imposes a very high cost for any\n// future breaking changes to the Slot class.\n\n\nvar globalKey = \"@wry/context:Slot\";\nvar host = Array;\n\nvar Slot = host[globalKey] || function () {\n  var Slot = makeSlotClass();\n\n  try {\n    Object.defineProperty(host, globalKey, {\n      value: host[globalKey] = Slot,\n      enumerable: false,\n      writable: false,\n      configurable: false\n    });\n  } finally {\n    return Slot;\n  }\n}();\n\nvar bind = Slot.bind,\n    noContext = Slot.noContext;\n\nfunction setTimeoutWithContext(callback, delay) {\n  return setTimeout(bind(callback), delay);\n} // Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\n\n\nfunction asyncFromGen(genFn) {\n  return function () {\n    var gen = genFn.apply(this, arguments);\n    var boundNext = bind(gen.next);\n    var boundThrow = bind(gen.throw);\n    return new Promise(function (resolve, reject) {\n      function invoke(method, argument) {\n        try {\n          var result = method.call(gen, argument);\n        } catch (error) {\n          return reject(error);\n        }\n\n        var next = result.done ? resolve : invokeNext;\n\n        if (isPromiseLike(result.value)) {\n          result.value.then(next, result.done ? reject : invokeThrow);\n        } else {\n          next(result.value);\n        }\n      }\n\n      var invokeNext = function invokeNext(value) {\n        return invoke(boundNext, value);\n      };\n\n      var invokeThrow = function invokeThrow(error) {\n        return invoke(boundThrow, error);\n      };\n\n      invokeNext();\n    });\n  };\n}\n\nfunction isPromiseLike(value) {\n  return value && typeof value.then === \"function\";\n} // If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\n\n\nvar wrappedFibers = [];\n\nfunction wrapYieldingFiberMethods(Fiber) {\n  // There can be only one implementation of Fiber per process, so this array\n  // should never grow longer than one element.\n  if (wrappedFibers.indexOf(Fiber) < 0) {\n    var wrap = function wrap(obj, method) {\n      var fn = obj[method];\n\n      obj[method] = function () {\n        return noContext(fn, arguments, this);\n      };\n    }; // These methods can yield, according to\n    // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n\n\n    wrap(Fiber, \"yield\");\n    wrap(Fiber.prototype, \"run\");\n    wrap(Fiber.prototype, \"throwInto\");\n    wrappedFibers.push(Fiber);\n  }\n\n  return Fiber;\n}\n\nexport { Slot, asyncFromGen, bind, noContext, setTimeoutWithContext as setTimeout, wrapYieldingFiberMethods };"],"sourceRoot":""}